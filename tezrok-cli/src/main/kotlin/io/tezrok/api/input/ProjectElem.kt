package io.tezrok.api.input

import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.tezrok.util.NameUtil
import org.springframework.web.bind.annotation.RequestMethod
import java.util.*

/**
 * Represents a model of a project loaded from a tezrok.json file.
 */
data class ProjectElem(
    val name: String = "",
    val productName: String = "",
    val version: String = "",
    val description: String = "",
    val frontend: Boolean? = null,

    @JsonProperty("package")
    val packagePath: String = "",
    val author: String = "",
    val modules: List<ModuleElem> = emptyList(),
    val git: GitElem? = null,
) {
    fun getModule(name: String): ModuleElem {
        return modules.find { it.name == name }
            ?: error("Module $name not found in project. Expected modules: " + modules.map { it.name })
    }

    @JsonIgnore
    fun getFinalProductName(): String = productName.ifBlank { name }

    override fun toString(): String {
        return "ProjectElem(name='$name')"
    }
}

data class ModuleElem(
    val name: String = "",
    val description: String = "",
    val type: ModuleType = ModuleType.Spring,
    val schema: SchemaElem? = null,
    val auth: AuthElem? = null,
    val task: TaskElem? = null,
    val dependencies: List<String>? = null,
    val spring: SpringElem? = null,
    // if true, then in module default search repositories will be created
    val searchable: Boolean? = null,
    // if true, then created service will have method to get new records from any entity
    val newRecords: Boolean? = null,
    // properties should be sorted by key, so we use TreeMap
    val properties: MutableMap<String, String?> = TreeMap(),
    // used to sort modules in project, default is 100
    val order: Int? = null
) {

    @JsonIgnore
    fun isSearchable(): Boolean = searchable == true

    @JsonIgnore
    fun getFinalOrder(): Int = order ?: 100

    override fun toString(): String {
        return "ModuleElem(name='$name')"
    }
}

enum class ModuleType {
    /**
     * Module is generated by tezrok as Spring Boot application
     */
    Spring,

    /**
     * Module is not generated by tezrok
     */
    Custom
}

data class SpringElem(val properties: SpringPropertiesElem? = null)

data class SpringPropertiesElem(
    val includes: List<String>? = null,
    val excludes: List<String>? = null
)

data class TaskElem(val enable: Boolean?)

data class AuthElem(
    val type: String,
    // if true, then standard user and roles will be created (user admin and ADMIN, USER roles)
    val stdInit: Boolean? = null
)

data class SchemaElem(
    val schemaName: String = "public", // by default schema name is public
    val importSchema: String? = null,
    val entities: List<EntityElem>? = null,
    val enums: List<EnumElem>? = null
)

data class EntityElem(
    val name: String,
    val description: String? = null,
    /**
     * If true, then custom repository will be created
     */
    val customRepository: Boolean? = null,
    /**
     * If true, then custom service will be created
     */
    val customService: Boolean? = null,
    val syntheticTo: String? = null,
    // if true, object won't be deleted from database, but will be marked as deleted
    val activable: Boolean? = null,
    // if true, createdAt field will be added to entity
    val createdAt: Boolean? = null,
    // if true, updatedAt field will be added to entity
    val updatedAt: Boolean? = null,
    // if true, entity will be searchable
    val searchable: Boolean? = null,
    // customizations for search entity
    val searchEntity: SearchEntity? = null,
    // if true, service will not be created
    val skipService: Boolean? = null,
    // if true, controller will not be created
    val skipController: Boolean? = null,
    val fields: List<FieldElem>,
    @Deprecated("Use methods instead")
    @JsonProperty("customMethods")
    val customMethodsOld: Set<String>? = null,
    @Deprecated("Use methods instead")
    @JsonProperty("customComments")
    val customCommentsOld: Map<String, String>? = null,
    @JsonDeserialize(`as` = LinkedHashSet::class)
    val methods: Set<MethodElem> = LinkedHashSet(),
    /**
     * Common properties for all standard methods
     */
    val stdMethodProps: MethodProps? = null,
    // initial data for entity in csv format
    val init: String? = null,
) {
    init {
        check(name.isNotBlank()) { "Entity name cannot be blank" }
        val firstChar = name.first()
        check(firstChar.isLetter()) {
            "Entity name should start with letter. Entity name: $name"
        }
        check(firstChar.isUpperCase()) {
            "Entity name should start with upper case letter. Entity name: $name"
        }
        if (customMethodsOld != null) {
            error("Entity '$name' contains deprecated customMethodsOld ($customMethodsOld). Use methods instead.")
        }
        if (customCommentsOld != null) {
            error("Entity '$name' contains deprecated customCommentsOld ($customCommentsOld). Use methods instead.")
        }
    }

    fun withMethods(methodNames: Map<String, String>): EntityElem {
        return withMethods(methodNames.map { MethodElem(it.key, it.value) }.toSet())
    }

    fun withMethods(vararg methodNames: Pair<String, String>): EntityElem {
        return withMethods(methodNames.map { MethodElem(it.first, it.second) }.toSet())
    }

    fun withMethods(vararg newMethods: MethodElem): EntityElem {
        return withMethods(newMethods.toSet())
    }

    fun withMethods(newMethods: Set<MethodElem>): EntityElem {
        val oldMethods = methods
        val methodNames = oldMethods.map { it.name }.toMutableSet()

        for (newMethod in newMethods) {
            check(newMethod.name.isNotBlank()) { "Method name cannot be blank" }
            val firstChar = newMethod.name.first()
            check(firstChar.isLetter()) {
                "Method name should start with letter, but found: ${newMethod.name}"
            }
            check(firstChar.isLowerCase()) {
                "Method name should start with lower case letter, but found: ${newMethod.name}"
            }
            check(!methodNames.contains(newMethod.name)) {
                "Method with name '${newMethod.name}' already exists"
            }
            methodNames.add(newMethod.name)
        }

        return this.copy(methods = oldMethods + newMethods)
    }

    fun getMethod(name: String): MethodElem {
        return methods.find { it.name == name }
            ?: error("Method $name not found in entity $name. Expected methods: " + methods.map { it.name })
    }

    fun tryGetMethod(name: String): MethodElem? {
        return methods.find { it.name == name }
    }

    /**
     * Returns field by name or throws an exception if field is not found
     */
    fun getField(name: String): FieldElem = tryGetField(name)
        ?: error("Field ($name) not found in entity (${this.name}). Expected fields: " + fields.map { it.name })

    /**
     * Returns field by name or null if field is not found
     */
    fun tryGetField(name: String): FieldElem? = fields.find { it.name == name }

    /**
     * Returns first primary field or throws an exception if primary field is not found
     */
    @JsonIgnore
    fun getPrimaryField(): FieldElem =
        fields.find { it.isPrimary() } ?: error("Primary field not found in entity $name")

    /**
     * Returns all primary and synthetic fields (but not logic ones)
     */
    @JsonIgnore
    fun getIdFields(): List<FieldElem> =
        fields.filter { field -> field.isPrimary() || field.logicField != true && field.isSynthetic() }

    @JsonIgnore
    fun getPrimaryFieldCount(): Int = fields.count { it.isPrimary() }

    @JsonIgnore
    val isSinglePrimary: Boolean = getPrimaryFieldCount() == 1

    @JsonIgnore
    fun isSynthetic(): Boolean = syntheticTo?.isNotEmpty() == true

    @JsonIgnore
    fun isNotSynthetic(): Boolean = !isSynthetic()

    @JsonIgnore
    fun isSearchable(): Boolean = searchable == true

    @JsonIgnore
    fun hasFullDto(): Boolean = skipService != true && skipController != true

    fun hasRelations(vararg relations: EntityRelation): Boolean =
        fields.any { it.isLogic() && it.hasRelations(*relations) }
}

data class EnumElem(
    val name: String,
    val values: List<String>
)

data class FieldElem(
    val name: String,
    // string, integer, long, enum or reference to another entity
    val type: String? = null,
    // reference to field of another entity
    val foreignField: String? = null,
    val description: String? = null,
    val required: Boolean? = null,
    val serial: Boolean? = null,
    val primary: Boolean? = null,
    /**
     * If field is primary, then this field can be used to set initial value for it
     */
    val primaryIdFrom: Long? = null,
    val pattern: String? = null,
    val minLength: Int? = null,
    val maxLength: Int? = null,
    val unique: Boolean? = null,
    val uniqueGroup: String? = null,
    @JsonProperty("default")
    val defValue: String? = null,
    // if true then field is not stored in database, mostly used for object fields
    val logicField: Boolean? = null,
    // true if field is synthetic and contains reference to another entity
    val syntheticTo: String? = null,
    val relation: EntityRelation? = null,
    // if true, entity will be searchable
    val searchable: Boolean? = null,
    val example: String? = null,
    // used for known fields like createdAt, updatedAt
    val metaTypes: Set<MetaType>? = null,
    // if true, then this field is synthetic and needed by other entity (field is added by user)
    val external: Boolean? = null
) {
    init {
        check(name.isNotBlank()) { "Field name cannot be blank" }
        val firstChar = name.first()
        check(firstChar.isLetter()) {
            "Field name should start with letter. Field name: $name"
        }
        check(firstChar.isLowerCase()) {
            "Field name should start with lower case letter. Field name: $name"
        }
        if (uniqueGroup != null) {
            check(uniqueGroup.isNotBlank()) { "Field unique group cannot be blank" }
            NameUtil.validateWhitespaces(uniqueGroup)
            check(unique != true) {
                "Field $name: uniqueGroup cannot be used with unique=true"
            }
        }
    }

    @JsonIgnore
    fun isPrimary(): Boolean = primary == true

    @JsonIgnore
    fun isNotPrimary(): Boolean = !isPrimary()

    @JsonIgnore
    fun isSynthetic(): Boolean = syntheticTo?.isNotEmpty() == true

    @JsonIgnore
    fun isNotSynthetic(): Boolean = !isSynthetic()

    @JsonIgnore
    fun isLogic(): Boolean = logicField == true

    @JsonIgnore
    fun isNotLogic(): Boolean = !isLogic()

    @JsonIgnore
    fun isSearchable(): Boolean = searchable == true

    @JsonIgnore
    fun hasUniqueGroup(): Boolean = uniqueGroup != null

    fun hasRelations(vararg relations: EntityRelation): Boolean = relation in relations

    fun hasMetaType(metaType: MetaType): Boolean = metaTypes?.contains(metaType) == true
}

data class MethodElem(
    /**
     * Name of the method
     */
    val name: String,
    /**
     * Comment for method and for OpenAPI specification
     */
    val description: String? = null,
    /**
     * If true, then method will be accessible by rest controller
     */
    val api: Boolean? = null,
    /**
     * Rest path for method. Used only if api is true
     */
    val apiPath: String? = null,
    /**
     * Http-method for api-method. Used only if api is true
     */
    val apiMethod: RequestMethod? = null,
    /**
     * Arguments for service method call
     */
    @JsonDeserialize(`as` = LinkedHashMap::class)
    val args: Map<String, Any?>? = null,
    /**
     * If true, then method will not be generated. This method probably standard.
     */
    val skipGenerate: Boolean? = null,
    /**
     * List of roles that can access this method
     */
    val roles: List<String>? = null,
    /**
     * List of permissions which are required to access this method
     */
    val permissions: List<String>? = null
) {
    @JsonIgnore
    fun isApi(): Boolean = api == true
}

/**
 * Common properties of a method.
 */
data class MethodProps(
    /**
     * If true, then method will be accessible by rest controller
     */
    val api: Boolean? = null,
    /**
     * List of roles that can access this method
     */
    val roles: List<String>? = null,
    /**
     * List of permissions which are required to access this method
     */
    val permissions: List<String>? = null
)

data class GitElem(
    // list of files to ignore
    val ignores: List<String>? = null,
    // list of files to exclude from std ignore list
    val excludes: List<String>? = null
)

data class SearchEntity(
    /**
     * Custom name for indexName in search engine
     */
    val indexName: String?
)

/**
 * Relation between entities
 */
enum class EntityRelation {
    OneToOne,

    OneToMany,

    ManyToOne,

    ManyToMany,
}

/**
 * Field meta type
 */
enum class MetaType {
    /**
     * Field is created when entity is created and never changed
     */
    CreatedAt,

    /**
     * Field is created when entity is created and updated when entity is updated
     */
    UpdatedAt,

    /**
     * Field is a string and email
     */
    Email,

    /**
     * Field is sensitive and should be stored and handled carefully
     */
    Sensitive
}
